<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes of Blue</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital@0;1&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #e0e0e0;
            height: 100vh;
            width: 100vw;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(to bottom, #87ceeb 0%, #4a90a4 50%, #2c5f7a 100%);
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .score {
            font-size: 32px;
            font-weight: bold;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
            font-size: 16px;
            z-index: 10;
        }

        .title-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #1a1a2e 0%, #2c5f7a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 1s ease-in;
        }

        .title-screen.hidden {
            display: none;
        }

        .title {
            font-size: 72px;
            font-style: italic;
            color: #87ceeb;
            text-shadow: 0 0 20px rgba(135, 206, 235, 0.5);
            margin-bottom: 20px;
            animation: pulse 2s ease-in-out infinite;
        }

        .subtitle {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 40px;
        }

        .start-btn {
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Crimson Text', serif;
            background: rgba(135, 206, 235, 0.3);
            border: 2px solid #87ceeb;
            color: #87ceeb;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: rgba(135, 206, 235, 0.5);
            box-shadow: 0 0 20px rgba(135, 206, 235, 0.5);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .trick-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 0 0 20px rgba(255, 235, 59, 0.8);
            pointer-events: none;
            z-index: 50;
            animation: trickPop 1s ease-out forwards;
        }

        @keyframes trickPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="title-screen" id="titleScreen">
        <div class="title">Echoes of Blue</div>
        <div class="subtitle">A story of longing and freedom</div>
        <button class="start-btn" id="startBtn">Begin</button>
    </div>

    <div class="hud">
        <div class="score">Score: <span id="score">0</span></div>
        <div>Combo: <span id="combo">0</span>x</div>
    </div>

    <div class="instructions">
        Arrow Keys: Swim | Space: Jump | Air Tricks: ↑ Front Flip | ↓ Back Flip | ← → Roll
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        canvas.width = 1200;
        canvas.height = 700;

        // Game state
        let gameStarted = false;
        let score = 0;
        let combo = 0;
        let comboTimer = 0;

        // Water level (y coordinate)
        const waterLevel = canvas.height * 0.6;

        // Dolphin object
        const dolphin = {
            x: canvas.width / 2,
            y: waterLevel + 100,
            vx: 0,
            vy: 0,
            angle: 0,
            targetAngle: 0,
            width: 60,
            height: 25,
            inWater: true,
            canJump: true,
            spinning: false,
            currentTrick: null,
            tricks: [],
            spinSpeed: 0,
            momentumBoost: 1
        };

        // Input handling
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === ' ' && dolphin.inWater && dolphin.canJump && gameStarted) {
                e.preventDefault();
                jump();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Particles
        let particles = [];

        class Particle {
            constructor(x, y, vx, vy, color, size) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.alpha = 1;
                this.life = 60;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // gravity
                this.alpha -= 1 / this.life;
                this.life--;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Jump function
        function jump() {
            dolphin.vy = -18 - Math.abs(dolphin.vx) * 0.5;
            dolphin.inWater = false;
            dolphin.canJump = false;
            dolphin.tricks = [];
            combo = 0;

            // Splash particles
            createSplash(dolphin.x, waterLevel);
        }

        // Create splash effect
        function createSplash(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI - Math.PI / 2;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x,
                    y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    'rgba(135, 206, 235, 0.6)',
                    Math.random() * 4 + 2
                ));
            }
        }

        // Perform trick
        function performTrick(trickName) {
            if (!dolphin.inWater && !dolphin.tricks.includes(trickName)) {
                dolphin.tricks.push(trickName);
                dolphin.currentTrick = trickName;

                // Add score
                let points = 100;
                if (trickName === 'Front Flip' || trickName === 'Back Flip') {
                    points = 150;
                    dolphin.spinSpeed = trickName === 'Front Flip' ? 0.15 : -0.15;
                } else if (trickName === 'Barrel Roll Left' || trickName === 'Barrel Roll Right') {
                    points = 100;
                    dolphin.spinSpeed = trickName === 'Barrel Roll Left' ? -0.1 : 0.1;
                }

                combo++;
                score += points * combo;
                comboTimer = 120; // 2 seconds

                // Show trick popup
                showTrickPopup(trickName, points * combo);

                setTimeout(() => {
                    dolphin.currentTrick = null;
                }, 500);
            }
        }

        // Show trick popup
        function showTrickPopup(trick, points) {
            const popup = document.createElement('div');
            popup.className = 'trick-popup';
            popup.textContent = `${trick} +${points}`;
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.remove();
            }, 1000);
        }

        // Update dolphin
        function updateDolphin() {
            // Swimming controls (only in water)
            if (dolphin.inWater) {
                if (keys['ArrowLeft']) {
                    dolphin.vx -= 0.5;
                    dolphin.targetAngle = Math.PI;
                }
                if (keys['ArrowRight']) {
                    dolphin.vx += 0.5;
                    dolphin.targetAngle = 0;
                }
                if (keys['ArrowUp']) {
                    dolphin.vy -= 0.3;
                }
                if (keys['ArrowDown']) {
                    dolphin.vy += 0.3;
                }

                // Water resistance
                dolphin.vx *= 0.95;
                dolphin.vy *= 0.92;

                // Speed limits in water
                dolphin.vx = Math.max(-8, Math.min(8, dolphin.vx));
                dolphin.vy = Math.max(-6, Math.min(6, dolphin.vy));

                // Reset jump when stable in water
                if (Math.abs(dolphin.vy) < 0.5) {
                    dolphin.canJump = true;
                }
            } else {
                // Air tricks
                if (keys['ArrowUp'] && !dolphin.tricks.includes('Front Flip')) {
                    performTrick('Front Flip');
                }
                if (keys['ArrowDown'] && !dolphin.tricks.includes('Back Flip')) {
                    performTrick('Back Flip');
                }
                if (keys['ArrowLeft'] && !dolphin.tricks.includes('Barrel Roll Left')) {
                    performTrick('Barrel Roll Left');
                }
                if (keys['ArrowRight'] && !dolphin.tricks.includes('Barrel Roll Right')) {
                    performTrick('Barrel Roll Right');
                }

                // Gravity
                dolphin.vy += 0.4;

                // Air resistance
                dolphin.vx *= 0.99;
            }

            // Apply velocity
            dolphin.x += dolphin.vx;
            dolphin.y += dolphin.vy;

            // Spin animation
            if (dolphin.spinSpeed !== 0) {
                dolphin.angle += dolphin.spinSpeed;
                dolphin.spinSpeed *= 0.95;
                if (Math.abs(dolphin.spinSpeed) < 0.01) {
                    dolphin.spinSpeed = 0;
                    dolphin.angle = 0;
                }
            }

            // Smooth angle transition
            if (dolphin.inWater && dolphin.spinSpeed === 0) {
                const angleDiff = dolphin.targetAngle - dolphin.angle;
                dolphin.angle += angleDiff * 0.1;
            }

            // Check water entry
            if (!dolphin.inWater && dolphin.y > waterLevel) {
                dolphin.inWater = true;
                dolphin.vy *= 0.3; // Reduce velocity on entry
                createSplash(dolphin.x, waterLevel);

                // Landing bonus
                if (dolphin.tricks.length > 0) {
                    const cleanEntry = Math.abs(dolphin.angle) < 0.3 || Math.abs(dolphin.angle - Math.PI) < 0.3;
                    if (cleanEntry) {
                        score += 50 * combo;
                    }
                }

                dolphin.tricks = [];
                combo = 0;
            }

            // Check water exit
            if (dolphin.inWater && dolphin.y < waterLevel - 20) {
                dolphin.inWater = false;
            }

            // Boundaries
            if (dolphin.x < 0) dolphin.x = 0;
            if (dolphin.x > canvas.width) dolphin.x = canvas.width;
            if (dolphin.y > canvas.height - 50) {
                dolphin.y = canvas.height - 50;
                dolphin.vy = -Math.abs(dolphin.vy) * 0.5;
            }

            // Combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer === 0) {
                    combo = 0;
                }
            }

            // Update particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => p.update());
        }

        // Draw water surface
        function drawWater() {
            // Water body
            ctx.fillStyle = 'rgba(44, 95, 122, 0.6)';
            ctx.fillRect(0, waterLevel, canvas.width, canvas.height - waterLevel);

            // Water surface with waves
            ctx.strokeStyle = 'rgba(135, 206, 235, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 0; x < canvas.width; x += 10) {
                const wave = Math.sin(x * 0.02 + Date.now() * 0.002) * 5;
                if (x === 0) {
                    ctx.moveTo(x, waterLevel + wave);
                } else {
                    ctx.lineTo(x, waterLevel + wave);
                }
            }
            ctx.stroke();

            // Underwater gradient
            const gradient = ctx.createLinearGradient(0, waterLevel, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(74, 144, 164, 0.3)');
            gradient.addColorStop(1, 'rgba(44, 95, 122, 0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, waterLevel, canvas.width, canvas.height - waterLevel);
        }

        // Draw dolphin
        function drawDolphin() {
            ctx.save();
            ctx.translate(dolphin.x, dolphin.y);
            ctx.rotate(dolphin.angle);

            // Dolphin body
            ctx.fillStyle = '#6b9ac4';
            ctx.beginPath();
            ctx.ellipse(0, 0, dolphin.width / 2, dolphin.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Lighter belly
            ctx.fillStyle = '#a8c7e0';
            ctx.beginPath();
            ctx.ellipse(0, 3, dolphin.width / 2.5, dolphin.height / 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Dorsal fin
            ctx.fillStyle = '#5a8ab0';
            ctx.beginPath();
            ctx.moveTo(-5, -dolphin.height / 2);
            ctx.lineTo(5, -dolphin.height / 2);
            ctx.lineTo(0, -dolphin.height / 2 - 12);
            ctx.closePath();
            ctx.fill();

            // Tail
            ctx.fillStyle = '#5a8ab0';
            ctx.beginPath();
            ctx.moveTo(-dolphin.width / 2, -5);
            ctx.lineTo(-dolphin.width / 2 - 15, -10);
            ctx.lineTo(-dolphin.width / 2 - 15, 10);
            ctx.lineTo(-dolphin.width / 2, 5);
            ctx.closePath();
            ctx.fill();

            // Pectoral fin
            ctx.fillStyle = '#5a8ab0';
            ctx.beginPath();
            ctx.ellipse(10, 0, 15, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(dolphin.width / 4, -5, 3, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.strokeStyle = '#4a7090';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(dolphin.width / 2 - 5, 0);
            ctx.lineTo(dolphin.width / 2 + 5, 0);
            ctx.stroke();

            ctx.restore();

            // Trail in water
            if (dolphin.inWater && Math.abs(dolphin.vx) > 2) {
                for (let i = 0; i < 3; i++) {
                    particles.push(new Particle(
                        dolphin.x - dolphin.vx * (i + 1),
                        dolphin.y + (Math.random() - 0.5) * 10,
                        0,
                        (Math.random() - 0.5) * 2,
                        'rgba(135, 206, 235, 0.4)',
                        Math.random() * 3 + 1
                    ));
                }
            }
        }

        // Draw background
        function drawBackground() {
            // Sky/Above water
            const skyGradient = ctx.createLinearGradient(0, 0, 0, waterLevel);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(1, '#4a90a4');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, waterLevel);

            // Tank walls
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            ctx.lineWidth = 10;
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

            // Platform
            ctx.fillStyle = 'rgba(139, 90, 43, 0.7)';
            ctx.fillRect(canvas.width / 2 - 100, 50, 200, 20);
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();
            drawWater();

            // Draw particles
            particles.forEach(p => p.draw());

            if (gameStarted) {
                updateDolphin();
            }

            drawDolphin();

            // Update HUD
            document.getElementById('score').textContent = score;
            document.getElementById('combo').textContent = combo;

            requestAnimationFrame(gameLoop);
        }

        // Start button
        document.getElementById('startBtn').addEventListener('click', () => {
            gameStarted = true;
            document.getElementById('titleScreen').classList.add('hidden');
        });

        // Start game loop
        gameLoop();
    </script>
</body>
</html>
