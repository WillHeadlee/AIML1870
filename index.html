<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>William Headlee</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@300;400&family=Outfit:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            background: #000000;
            color: #f5f5f5;
            height: 100vh;
            width: 100vw;
        }

        #particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            padding: 2rem;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: clamp(3rem, 8vw, 8rem);
            font-weight: 300;
            margin-bottom: 1.5rem;
            letter-spacing: 0.02em;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.5);
        }

        .greeting {
            font-size: clamp(1rem, 2vw, 1.5rem);
            font-weight: 300;
            letter-spacing: 0.05em;
            opacity: 0.9;
            max-width: 600px;
            text-shadow: 0 1px 10px rgba(0, 0, 0, 0.5);
        }

        .projects {
            margin-top: 3rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            justify-content: center;
            max-width: 800px;
        }

        .project-link {
            padding: 1rem 2rem;
            background: rgba(127, 255, 0, 0.1);
            border: 1px solid rgba(127, 255, 0, 0.3);
            border-radius: 8px;
            color: #7fff00;
            text-decoration: none;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .project-link:hover {
            background: rgba(127, 255, 0, 0.2);
            border-color: rgba(127, 255, 0, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(127, 255, 0, 0.3);
        }

        @media (prefers-reduced-motion: reduce) {
            #particleCanvas {
                display: none;
            }

            body {
                background: #000000;
            }
        }

        @media (max-width: 768px) {
            h1 {
                margin-bottom: 1rem;
            }

            .greeting {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>

    <div class="content">
        <h1>William Headlee</h1>
        <p class="greeting">Hello, welcome to my corner of the internet</p>

        <div class="projects">
            <a href="stellar-web/" class="project-link">Stellar Web Game</a>
            <a href="echoes-of-blue/" class="project-link">Echoes of Blue</a>
            <a href="starfield/" class="project-link">Starfield</a>
            <a href="hello-world/" class="project-link">Hello World</a>
        </div>
    </div>

    <script>
        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        if (!prefersReducedMotion) {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Mouse position
            let mouse = {
                x: null,
                y: null,
                radius: 150
            };

            window.addEventListener('mousemove', (e) => {
                mouse.x = e.x;
                mouse.y = e.y;
            });

            window.addEventListener('mouseleave', () => {
                mouse.x = null;
                mouse.y = null;
            });

            // Touch support
            window.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    mouse.x = e.touches[0].clientX;
                    mouse.y = e.touches[0].clientY;
                }
            });

            window.addEventListener('touchend', () => {
                mouse.x = null;
                mouse.y = null;
            });

            // Blob colors - neon green/chartreuse palette
            const colors = [
                { r: 127, g: 255, b: 0 },    // chartreuse
                { r: 173, g: 255, b: 47 },   // green yellow
                { r: 0, g: 255, b: 127 },    // spring green
                { r: 50, g: 205, b: 50 },    // lime green
                { r: 154, g: 255, b: 102 },  // light neon green
                { r: 57, g: 255, b: 20 }     // neon green
            ];

            // Particle class
            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.size = Math.random() * 120 + 60; // 60-180px - larger blobs
                    this.baseSize = this.size;
                    this.speedX = (Math.random() - 0.5) * 0.4;
                    this.speedY = (Math.random() - 0.5) * 0.4;
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                    this.opacity = Math.random() * 0.3 + 0.4; // 0.4-0.7 - more visible
                    this.angle = Math.random() * Math.PI * 2;
                    this.angleSpeed = (Math.random() - 0.5) * 0.015;
                    this.blur = Math.random() * 15 + 10; // 10-25px - more blur for glow
                    this.targetX = this.x;
                    this.targetY = this.y;

                    // For organic movement
                    this.offset = Math.random() * Math.PI * 2;
                    this.waveSpeed = Math.random() * 0.015 + 0.008;
                    this.waveAmplitude = Math.random() * 40 + 30;
                }

                update() {
                    // Ambient wave motion
                    this.offset += this.waveSpeed;
                    this.targetX += this.speedX + Math.sin(this.offset) * 0.3;
                    this.targetY += this.speedY + Math.cos(this.offset * 0.7) * 0.3;

                    // Wrap around edges
                    if (this.targetX > canvas.width + this.size) this.targetX = -this.size;
                    if (this.targetX < -this.size) this.targetX = canvas.width + this.size;
                    if (this.targetY > canvas.height + this.size) this.targetY = -this.size;
                    if (this.targetY < -this.size) this.targetY = canvas.height + this.size;

                    // Mouse interaction - repulsion
                    if (mouse.x != null && mouse.y != null) {
                        const dx = mouse.x - this.targetX;
                        const dy = mouse.y - this.targetY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < mouse.radius) {
                            const force = (mouse.radius - distance) / mouse.radius;
                            const angle = Math.atan2(dy, dx);

                            // Repel particles
                            this.targetX -= Math.cos(angle) * force * 8;
                            this.targetY -= Math.sin(angle) * force * 8;

                            // Deform size slightly
                            this.size = this.baseSize * (1 + force * 0.3);
                        } else {
                            // Return to base size
                            this.size += (this.baseSize - this.size) * 0.1;
                        }
                    } else {
                        this.size += (this.baseSize - this.size) * 0.1;
                    }

                    // Smooth movement
                    this.x += (this.targetX - this.x) * 0.05;
                    this.y += (this.targetY - this.y) * 0.05;

                    // Rotation
                    this.angle += this.angleSpeed;
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);

                    // Add neon glow effect with multiple layers
                    ctx.filter = 'none';

                    // Outer glow
                    ctx.shadowBlur = this.blur * 2;
                    ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.8})`;

                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity * 0.3})`;

                    ctx.beginPath();
                    const points = 6;
                    for (let i = 0; i < points; i++) {
                        const angle = (Math.PI * 2 * i) / points;
                        const variance = Math.sin(this.offset * 3 + i) * 0.25 + 0.9;
                        const radius = this.size * variance / 2;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            const prevAngle = (Math.PI * 2 * (i - 1)) / points;
                            const prevVariance = Math.sin(this.offset * 3 + (i - 1)) * 0.25 + 0.9;
                            const prevRadius = this.size * prevVariance / 2;
                            const prevX = Math.cos(prevAngle) * prevRadius;
                            const prevY = Math.sin(prevAngle) * prevRadius;

                            const cpX = (prevX + x) / 2 * 1.3;
                            const cpY = (prevY + y) / 2 * 1.3;

                            ctx.quadraticCurveTo(cpX, cpY, x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Core blob with stronger color
                    ctx.shadowBlur = this.blur;
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;

                    ctx.beginPath();
                    for (let i = 0; i < points; i++) {
                        const angle = (Math.PI * 2 * i) / points;
                        const variance = Math.sin(this.offset * 3 + i) * 0.25 + 0.9;
                        const radius = this.size * variance / 2 * 0.7;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            const prevAngle = (Math.PI * 2 * (i - 1)) / points;
                            const prevVariance = Math.sin(this.offset * 3 + (i - 1)) * 0.25 + 0.9;
                            const prevRadius = this.size * prevVariance / 2 * 0.7;
                            const prevX = Math.cos(prevAngle) * prevRadius;
                            const prevY = Math.sin(prevAngle) * prevRadius;

                            const cpX = (prevX + x) / 2 * 1.3;
                            const cpY = (prevY + y) / 2 * 1.3;

                            ctx.quadraticCurveTo(cpX, cpY, x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.restore();
                }
            }

            // Determine particle count based on screen size
            const isMobile = window.innerWidth < 768;
            const particleCount = isMobile ? 8 : 12;

            // Create particles
            const particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animate);
            }

            animate();
        }
    </script>
</body>
</html>
